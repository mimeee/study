## 字符编码
- 多字节字符集 -- 中文: 多个字节
- unicode字符集 -- 中文: 2个字节

---

- ## 线性表链表篇
    + 线性表概念与原理
        * 线性表的定义
            - 存在唯一的一个被称作 “第一个” 的元素
            - 存在惟一的一个被称作 “最后一个” 的元素
            - 除第一个之外，集合中的每个元素均只有一个前驱
            - 除最后一个之外，集合中的每个元素均只有一个后继  
            其意思就是除了第一个和最后一个元素外，表中的每个元素都是前面只有一个元素，后面只有一个元素。并且只有一个开始元素，只有一个结束元素。
        * 简单线性表的存在形式
            - 数组 `[3,5,4,2,6,4]`  
              在计算机中，数组就是按照地址的顺序排布的( 00x1,00x2,00x3 ...)，
            - 比数组更近一步的是在 *数组的内容中放它的后继的地址*  
                   
                |2|5|4|-1|1|3|
                | --- | --- |--- | --- | --- | --- |
                |0|1|2|3|4|5|
                
            - 结构单元，前面一个元素代表自身的编号，后面一个元素代表他后继的编号(单链表)
            
                |1|3|
                | --- | --- |
                
                |2|4|
                | --- | --- |
                
                |3|2|
                | --- | --- |
                
                |4|0|
                | --- | --- |
                
            - 线性表的操作
                + 线性表初始化
                + 线性表遍历
                + 线性表插入元素
                + 线性表删除元素
            - 线性表的实现
                + [顺序表](sequence_list.html)
                    * 创建线性表
                    * 销毁线性表
                    * 清空线性表
                    * 判断线性表是否为空
                    * 获取线性表的长度
                    * 获取指定元素
                    * 寻找第一个满足e的数据元素的位序
                    * 获取指定元素的前驱
                    * 获取指定元素的后继
                    * 在第i各个位置插入元素
                    * 删除第i个位置的元素
                    * 遍历线性表
                
- ## 队列篇
    + 队列的实现原理
        * 原则: 先进先出 (first in first out) FIFO
        * 要素: 队列头，队列尾
        * 队列的变化: 当队列变化的时候，如果是指针不动，元素动的话，当队列头移除时，整个队列的元素都要向前移动一位，效率低下；如果是指针动，元素不动，则当队列头移除的时候，只需要移动一下指针即可。   
        ![](image/normal_queue.png)
        * 类型: 普通队列，环形队列
            如果使用指针移动，在普通队列中前面被移除的内存在被移除的时候依然是被占用的，不能得到二次利用。如果用环形队列就可以解决这个问题。  
            ![](image/circle_queue.png)
        * 队列的实现方式([环形队列](circle_queue.html))
            - 创建队列
            - 销毁队列
            - 清空队列
            - 判断队列是否为空
            - 队列长度
            - 新元素入队
            - 首元素出队
            - 遍历队列

- ## 栈篇
    + 栈的实现原理
        * 原则: 先进后出 (first in last out) FILO
        * 要素: 栈顶，栈底
        * 易混淆概念: 栈不等于堆，栈是一种数据结构，堆是另外一种数据结构  
        * 栈的机制示意图  
            ![](image/stack.png)
        * 栈的实现
            - 创建栈( 分配空间，设定栈容量，栈顶)
            - 判断栈是否为空
            - 判断栈是否已满
            - 清空栈
            - 栈中已有元素的个数
            - 入栈，栈顶上升
            - 出栈，栈顶下降
            - 遍历栈中所有元素
- ## 树篇
    + 树的基本概念  
    ![](image/tree.png)
        - 孩子(B,C,D,E,F,G)
        - 双亲/父节点(A,B,C)
        - 度: 一个节点的直接孩子(A->(B,C),B->(D,E)...)
        - 叶子(终端节点): 度为0的节点(D,E,F,G)
        - 根(非终端节点): 度不为0的节点(A,B,C)
        - 有序数: 结点之间不可以随意调换顺序
        - 无序数: 结点之间可以随意调换顺序
        - 深度: 层
        - 结点深度: 该结点自上而下是第几层就是该结点的深度(B的结点深度为2，D的结点深度为3)
        - 树的深度: 结点的最大深度(树的深度为3)
        - 森林: 不交叉的两个树就可以形成森林
    + 二叉树
        * 要求
            - 所有结点的度都小于等于2
            - 有序树
        * 性质  
            - 在二叉树的第i层上最多有(2^i-1)个结点
            - 深度为k的二叉树，最多有((2^k)-1)个结点
            - 如果终端节点数为n，度为2的结点数为m，则n=m+1
            - 具有n个结点的二叉树的深度为(int)(log2(n))+1
        * 遍历方式  
        ![](image/tree_simple.png)
            - 二叉树的前序遍历:根左右(A->B->C)
            - 二叉树的中序遍历:左根右(B->A->C)
            - 二叉树的后序遍历:左右根(B->C->A)
        * 满二叉树 所有结点的度都等于2
        * 完全二叉树 从满二叉树从提取一部分的树  
            ![](image/tree_complete.png)
            - 定义  对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号(编号是有固定顺序的，就是从上到下，从左到右依次分配)从1至n的结点————对应时称之为完全二叉树
        * 二叉树的存储结构
            - 顺序存储结构  
            ![](image/sequence_storage.png)
            - 链式存储结构
            ![](image/link_storage.png)
        * 二叉树的实现
            - 树的创建和销毁
            - 树中结点的搜索
            - 树中结点的添加与删除
            - 树中结点的遍历+

- ## 图篇
    + 什么是图
        * 无向图  
        ![](image/no_direct_pic.png)
        * 有向图  
        ![](no_direct_pic.png)
    + 图的要素  
        ![](image/element_in_pic.png)
        * 有向图
            - 顶点
            - 弧
                + 弧头
                + 弧尾
                + 出度(对于某个顶点来说，从该顶点向外，则为出度)  
                + 入度(对于某个顶点来说，从该顶点向内，则为入度)
                    * 可以计算出度入度为多少对于某一个顶点来说
                ![](image/arc_pic.png)
        * 无向图  
            ![](image/element_in_no_redi_pic.png)
            - 顶点
            - 边
            - 邻接点
        * 连通图
            - 在无向图上，任意两个节点都可以通过边到达
        * 完全图
            - 当一个点连接另外一个点的时候，不会画出另外一个边的时候，就称为完全图
            - 边数 = n(n-1)/2
        * 生成树
            - 两个点相连，仅仅只有一条道路可达
            - 边数 = n - 1  
            ![](image/pic_tree.png)
    + 图的存储结构
        * **邻接矩阵** 存储有向图或者无向图 数组表示
            - 存储元素: 顶点、弧
            - 顶点的表示方法: 顶点索引、顶点数据
            - 弧的表示方法: 邻接矩阵  
                ![](image/nerib_rect.png)
        * **邻接表** 存储有向图 链表表示
            - 存储元素: 顶点、弧
            - 顶点的表示方式: 顶点索引、出弧链表头指针、顶点数据
            - 弧的表示方法: 弧头顶点索引、下一条弧指针、弧数据  
            ![](image/arc_expression.png)  
            ![](image/arc_expression_abstract.png)
            ![](image/arc_expression_abstract2.png)
        * **十字链表** 存储有向图 链表表示
            - 存储元素: 顶点、弧
            - 顶点的表示方式: 顶点索引、顶点数据、该顶点为弧尾的弧结点指针、该顶点为弧头的弧结点指针
            - 弧的表示方法: 弧尾顶点索引、弧头顶点索引、弧尾相同的下一条弧的指针、弧头相同的下一条弧的指针、弧数据    
            ![](image/ten_expression_abstract.png)
        * **邻接多重表** 存储无向图 链表表示
            - 存储元素: 顶点、弧
            - 顶点的表示方式: 顶点索引、顶点数据、链接该点的边
            - 弧的表示方法: A顶点索引、B顶点索引、与A顶点相链接的下一条边的指针、与B顶点相链接的下一条边的指针、边数据  
            ![](image/element_nul_pic.png)
    + 图的遍历操作
        * 深度遍历
        * 广度遍历——分层
    + 最小生成树
        * 解决的问题
        * 普里姆算法
            - 通过点查找边
            - 记录的集合
                + 已选点集合
                + 已选边集合
                + 待选边集合
            - 选取步骤: 
                1. 首先先随机选取一个点作为初始点放入 **点集合**中
                2. 将与该点相关联的边放入 **待边的集合**中
                3. 在 **待选边集合**中选择权值最小的边放入 **边集合**，已经与该边相关联的另外一个点放入 **点集合**中
                4. 扩充 **待选边集合**始之包含包含与 **点集合**中所有的边
                5. 重复第三步直至所有点被选择  
                ![](image/min_tree_gen_1.png)
        * 克鲁斯卡尔算法
            - 通过边查找点
            - 记录的集合
                + 已涉及点集合
                + 已选边集合
                + 待选边集合
            - 选取步骤: 
                1. 首先将所有的边放入 **待选边集合**中
                2. 再所有边中寻找权值最小的边，将边放入 **已选边集合**，同时添加至 **已涉及点集合**，保证 **已选边集合**不存在闭环
                3. 继续第2步，直到所有 **已涉及点集合**等于节点数(如果选择的边与前边的 **已涉及点集合**关系则再添加一个新的集合，最后所有的集合集中在一块)  
                ![](image/min_tree_gen_2.png)
        * 编码实现 ———— 图的存储与图的遍历
            - 初始化
                + 顶点个数初始化
                + 存放顶点数组初始化
                + 链接矩阵初始化(声明，并把里面的值全都赋为0)
            - 向图中加入顶点(结点)
            - 重置顶点(将isVisited属性设置为0)
            - 为有向图设置邻接矩阵
            - 为无向图设置邻接矩阵
            - 打印邻接矩阵
            - 深度优先遍历
            - 广度优先遍历
            - 从矩阵中获取权值
            - 广度优先遍历实现函数
            - 公共参数
                + 图中最多可以容纳的顶点数
                + 已经添加的顶点(结点)个数
                + 用来存放顶点数组
                + 用来存放邻接矩阵
            - 结点的属性
                + 数据
                + 是否被访问(BOOLEAN)
    

